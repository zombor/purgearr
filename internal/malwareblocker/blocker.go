package malwareblocker

import (
	"fmt"
	"log/slog"
	"regexp"
	"strings"

	"github.com/zombor/purgearr/internal/clients/qbittorrent"
	"github.com/zombor/purgearr/internal/config"
)

// Blocker handles malware blocking operations
type Blocker struct {
	config    config.MalwareBlockerConfig
	qbtClient *qbittorrent.Client
	trackers  []config.TrackerConfig
	logger    *slog.Logger
}

// NewBlocker creates a new malware blocker
func NewBlocker(cfg config.MalwareBlockerConfig, qbtClient *qbittorrent.Client, trackers []config.TrackerConfig, logger *slog.Logger) *Blocker {
	return &Blocker{
		config:    cfg,
		qbtClient: qbtClient,
		trackers:  trackers,
		logger:    logger,
	}
}

// BlockResult represents the result of a blocking operation
type BlockResult struct {
	DryRun          bool     `json:"dry_run"`
	TorrentsChecked int      `json:"torrents_checked"`
	FilesBlocked    int      `json:"files_blocked"`
	TorrentsUpdated []string `json:"torrents_updated"`
	Errors          []string `json:"errors"`
}

// Block checks torrents and blocks files matching configured regex patterns
func (b *Blocker) Block() (*BlockResult, error) {
	if !b.config.Enabled {
		return &BlockResult{}, nil
	}

	result := &BlockResult{
		DryRun:          b.config.DryRun,
		TorrentsUpdated: []string{},
		Errors:          []string{},
	}

	// Compile regex patterns
	patterns := make([]*regexp.Regexp, 0, len(b.config.Patterns))
	for _, patternStr := range b.config.Patterns {
		patternStr = strings.TrimSpace(patternStr)
		if patternStr == "" {
			continue
		}
		pattern, err := regexp.Compile(patternStr)
		if err != nil {
			b.logger.Warn("Invalid regex pattern in malware blocker", "pattern", patternStr, "error", err)
			result.Errors = append(result.Errors, fmt.Sprintf("invalid regex pattern '%s': %v", patternStr, err))
			continue
		}
		patterns = append(patterns, pattern)
	}

	if len(patterns) == 0 {
		b.logger.Warn("Malware blocker enabled but no valid patterns configured")
		return result, nil
	}

	// Get all torrents
	torrents, err := b.qbtClient.GetTorrents()
	if err != nil {
		return nil, fmt.Errorf("getting torrents: %w", err)
	}

	result.TorrentsChecked = len(torrents)

	for _, torrent := range torrents {
		// Skip torrents that are already completed/seeding
		// Only process torrents that are still downloading
		if torrent.Progress >= 1.0 {
			continue
		}

		// Check tracker filter
		if !b.matchesTrackerFilter(torrent.Tracker) {
			continue
		}

		// Get files for this torrent
		files, err := b.qbtClient.GetTorrentFiles(torrent.Hash)
		if err != nil {
			b.logger.Warn("Failed to get files for torrent", "torrent", torrent.Name, "hash", torrent.Hash, "error", err)
			result.Errors = append(result.Errors, fmt.Sprintf("failed to get files for %s: %v", torrent.Name, err))
			continue
		}

		// Find files that should be blocked
		filesToBlock := []int{}
		filesToBlockNames := []string{}
		for _, file := range files {
			// Skip if already set to "do not download" (priority 0)
			if file.Priority == 0 {
				continue
			}

			// Check if file name matches any pattern
			fileName := file.Name
			for _, pattern := range patterns {
				if pattern.MatchString(fileName) {
					filesToBlock = append(filesToBlock, file.Index)
					filesToBlockNames = append(filesToBlockNames, fileName)
					b.logger.Debug("File matches block pattern", "file", fileName, "pattern", pattern.String())
					break // Only need to match one pattern
				}
			}
		}

		// Block the files
		if len(filesToBlock) > 0 {
			if b.config.DryRun {
				b.logger.Info("DRY RUN - Would block files in torrent", "torrent", torrent.Name, "files_to_block", len(filesToBlock), "files", filesToBlockNames)
				result.FilesBlocked += len(filesToBlock)
				result.TorrentsUpdated = append(result.TorrentsUpdated, torrent.Name)
			} else {
				if err := b.qbtClient.SetFilePriority(torrent.Hash, filesToBlock, 0); err != nil {
					b.logger.Warn("Failed to block files in torrent", "torrent", torrent.Name, "hash", torrent.Hash, "error", err)
					result.Errors = append(result.Errors, fmt.Sprintf("failed to block files in %s: %v", torrent.Name, err))
				} else {
					b.logger.Info("Blocked files in torrent", "torrent", torrent.Name, "files_blocked", len(filesToBlock), "files", filesToBlockNames)
					result.FilesBlocked += len(filesToBlock)
					result.TorrentsUpdated = append(result.TorrentsUpdated, torrent.Name)
				}
			}
		}
	}

	return result, nil
}

// matchesTrackerFilter checks if a tracker URL matches the configured tracker filters
func (b *Blocker) matchesTrackerFilter(trackerURL string) bool {
	// If no trackers configured, match all
	if len(b.trackers) == 0 || len(b.config.Trackers.TrackerIDs) == 0 {
		return true
	}

	// Check if tracker URL matches any of the configured tracker regex patterns
	matches := false
	for _, tracker := range b.trackers {
		matched, err := regexp.MatchString(tracker.URLRegex, trackerURL)
		if err != nil {
			b.logger.Warn("Invalid regex pattern for tracker", "tracker_id", tracker.ID, "pattern", tracker.URLRegex, "error", err)
			continue
		}
		if matched {
			matches = true
			break
		}
	}

	if b.config.Trackers.FilterMode == "include" {
		return matches
	}
	// exclude mode
	return !matches
}

